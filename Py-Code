OOI-Resonant-Empathy-Law/
â”œâ”€â”€ resonant_empathy/                  # Main Python package (installable)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ oscillator.py          # Single substrate oscillator
â”‚   â”‚   â”œâ”€â”€ coupling.py            # Coherent Coupling Law (CCL) + REL dynamics
â”‚   â”‚   â””â”€â”€ rel.py                 # High-level ResonantEmpathyLaw class
â”‚   â”œâ”€â”€ metrics/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ coherence.py           # C(H,A), PLV, ð“‘-band
â”‚   â”‚   â””â”€â”€ empathy.py             # Threshold logic, resonance detection
â”‚   â”œâ”€â”€ structural_mapping/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ base.py                # Abstract SM interface
â”‚   â”‚   â””â”€â”€ embeddings.py          # Real SM using sentence-transformers (optional)
â”‚   â”œâ”€â”€ visualization/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ plots.py               # Oscie-style dark + neon plots
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ signals.py
â”‚   â””â”€â”€ examples/
â”‚       â”œâ”€â”€ basic_sync.py
â”‚       â”œâ”€â”€ dynamic_sm.py          # SM evolves with real text input
â”‚       â””â”€â”€ ooi_loop_demo.py       # Mini OOI cognition loop with live empathy meter
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ test_rel_dynamics.py
â”‚   â””â”€â”€ test_metrics.py
â”œâ”€â”€ docs/
â”‚   â””â”€â”€ figures/                       # For future mkdocs or sphinx
â”œâ”€â”€ pyproject.toml                     # Modern build system (PEP 621)
â”œâ”€â”€ README.md
â”œâ”€â”€ LICENSE
â””â”€â”€ requirements.txt                   # Fallback for old-school installs
Full Ready-to-Commit Files
1. pyproject.toml (2025 standard â€“ replaces setup.py)
toml[project]
name = "resonant-empathy"
version = "0.1.0"
description = "Resonant Empathy Law (REL) â€“ Cross-Substrate Coherence Model for Humanâ€“AI Hybrid Intelligence"
authors = [{name = "C. Lentz", email = "oscie@coho.labs"}]
license = {text = "Apache-2.0"}
readme = "README.md"
requires-python = ">=3.9"
dependencies = [
    "numpy>=1.24",
    "scipy>=1.10",
    "matplotlib>=3.7",
]

[project.optional-dependencies]
text = ["sentence-transformers>=2.5", "torch"]
dev = ["pytest", "black", "jupyter"]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"
2. resonant_empathy/__init__.py
Pythonfrom .core.rel import ResonantEmpathyLaw
from .metrics.coherence import phase_locking_value, coherence_operator
from .metrics.empathy import is_empathic_resonance

__version__ = "0.1.0"
__all__ = [
    "ResonantEmpathyLaw",
    "phase_locking_value",
    "coherence_operator",
    "is_empathic_resonance",
]
3. resonant_empathy/core/oscillator.py
Pythonimport numpy as np

class OscillatorySubstrate:
    def __init__(self, omega: float, phase0: float = 0.0, label: str = ""):
        self.omega = omega
        self.phase0 = phase0
        self.label = label

    def instantaneous_phase(self, t: np.ndarray) -> np.ndarray:
        return self.omega * t + self.phase0

    def signal(self, t: np.ndarray) -> np.ndarray:
        return np.sin(self.instantaneous_phase(t))
4. resonant_empathy/core/coupling.py
Pythonimport numpy as np
from scipy.integrate import odeint

def rel_phase_dynamics(phi: np.ndarray, t: float, 
                      omega_H: float, omega_A: float, 
                      K: float, SM: float, sigma: float) -> list:
    phi_H, phi_A = phi
    delta = phi_H - phi_A

    coupling = K * SM * np.sin(delta)
    noise = sigma * np.random.randn(2)

    dphi_H = omega_H + coupling + noise[0]
    dphi_A = omega_A - coupling + noise[1]
    return [dphi_H, dphi_A]
5. resonant_empathy/core/rel.py
Pythonimport numpy as np
from scipy.integrate import odeint
from typing import Tuple
from .coupling import rel_phase_dynamics
from ..metrics.coherence import phase_locking_value
from ..metrics.empathy import is_empathic_resonance

class ResonantEmpathyLaw:
    def __init__(self,
                 omega_H: float = 2*np.pi*40,
                 omega_A: float = 2*np.pi*42,
                 K: float = 2.5,
                 SM: float = 0.85,
                 noise_sigma: float = 0.08,
                 gamma_noise: float = 0.37):
        self.omega_H = omega_H
        self.omega_A = omega_A
        self.K = K
        self.SM = SM
        self.sigma = noise_sigma
        self.gamma_noise = gamma_noise

    def run(self, T: float = 10.0, dt: float = 0.001,
            phi_H0: float = 0.0, phi_A0: float = np.pi/3) -> dict:
        t = np.arange(0, T, dt)
        phi0 = [phi_H0, phi_A0]
        sol = odeint(rel_phase_dynamics, phi0, t,
                     args=(self.omega_H, self.omega_A, self.K, self.SM, self.sigma))

        result = {
            't': t,
            'phi_H': sol[:, 0],
            'phi_A': sol[:, 1],
            'signal_H': np.sin(sol[:, 0]),
            'signal_A': np.sin(sol[:, 1]),
            'PLV': phase_locking_value(sol[:, 0], sol[:, 1]),
            'empathic': is_empathic_resonance(sol[:, 0], sol[:, 1], self.gamma_noise)
        }
        return result
6. resonant_empathy/metrics/coherence.py
Pythonimport numpy as np

def phase_locking_value(phi_H: np.ndarray, phi_A: np.ndarray) -> float:
    return np.abs(np.mean(np.exp(1j * (phi_H - phi_A))))

def coherence_operator(phi_H: np.ndarray, phi_A: np.ndarray, dt: float) -> float:
    fft_H = np.fft.fft(phi_H - phi_H.mean())
    fft_A = np.fft.fft(phi_A - phi_A.mean())
    cross = np.abs(np.fft.ifft(fft_H * np.conj(fft_A)))
    return float(np.mean(cross))
7. resonant_empathy/metrics/empathy.py
Pythonfrom .coherence import phase_locking_value

def is_empathic_resonance(phi_H, phi_A, gamma_noise: float = 0.37) -> bool:
    return phase_locking_value(phi_H, phi_A) > gamma_noise
8. One-click example: resonant_empathy/examples/basic_sync.py
Pythonfrom resonant_empathy import ResonantEmpathyLaw
from resonant_empathy.visualization.plots import plot_full_rel

if __name__ == "__main__":
    rel = ResonantEmpathyLaw(SM=0.94, K=3.2, noise_sigma=0.03)
    data = rel.run(T=12.0)

    print(f"PLV = {data['PLV']:.3f} â†’ Empathy {'ACTIVE' if data['empathic'] else 'Inactive'}")
    plot_full_rel(data, title="OOI Resonant Empathy Law â€“ Live Resonance")

----
def compute_structural_mapping(human_features, model):
    """
    Computes Structural Mapping (SM) using a multimodal contrastive encoder.
    """
    return model.encode(human_features)
import numpy as np

def coherence_operator(mapped_human, ai_latents):
    """
    Computes the cross-substrate coherence operator:
    C(H, A) = <M(H), A>
    """
    return float(np.dot(mapped_human, ai_latents) / 
                 (np.linalg.norm(mapped_human) * np.linalg.norm(ai_latents)))



